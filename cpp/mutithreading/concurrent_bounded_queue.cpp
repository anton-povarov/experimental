// Generated by ChatGPT
//
// Task 1: Thread-safe Bounded Queue
//
// Goal: Implement a thread-safe bounded queue with blocking push and pop operations. Requirements
// 	•	Use only C++ standard library (<mutex>, <condition_variable>, <queue>).
// 	•	push() should block when the queue is full, and resume when space becomes available.
// 	•	pop() should block when the queue is empty, and resume when an element is added.
// 	•	Make sure the queue works with multiple producer and consumer threads.
// 	•	Add a simple test program with several producers and consumers.

// Evaluation Focus
// 	•	Proper use of std::mutex and std::condition_variable
// 	•	Avoiding deadlocks and spurious wakeups
// 	•	Understanding of the producer–consumer problem
// 	•	Clean RAII design

#include <cstddef>
#include <print>
#include <vector>

#include "concurrent_bounded_queue.hpp"

#include "meow/defer.hpp"

#define MEOW_ENTER(body)                                                                                     \
	{                                                                                                        \
		body;                                                                                                \
	} /**/

// ------------------------------------------------------------------------------------------------

void test_1() // this just shouldn't deadlock
{
	MEOW_ENTER({ std::print("============= {} starting =============\n\n", __FUNCTION__); });
	MEOW_DEFER({ std::print("============= {} finished =============\n\n", __FUNCTION__); });

	BoundedQueue<int> queue(5);

	std::thread producer([&queue]() {
		for (int i = 0; i < 100; i++) {
			queue.push(i);
		}
		queue.close();
	});

	std::vector<std::thread> consumers;
	for (int i = 0; i < 3; i++) {
		std::thread t([&queue]() {
			int value;
			while (queue.pop(value)) {
				std::print("thread got value {}\n", value);
			}
		});
		consumers.push_back(std::move(t));
	}

	producer.join();
	for (auto &t : consumers)
		t.join();
}

// ------------------------------------------------------------------------------------------------
// move only value support

struct move_only_t
{
	int         value;
	std::string strval;

	move_only_t()
	    : value{-1}
	    , strval{}
	{}

	explicit move_only_t(int v, std::string str)
	    : value{v}
	    , strval{str}
	{}

	// move
	move_only_t(move_only_t &&other)
	    : value(other.value)
	    , strval(other.strval)
	{
		other.value = -1;
		other.strval = "";
	}

	move_only_t &operator=(move_only_t &&other)
	{
		value = other.value;
		strval = other.strval;
		other.value = -1;
		other.strval = "";
		return *this;
	}

	// no copy
	move_only_t(move_only_t const &) = delete;
	move_only_t &operator=(move_only_t const &) = delete;
};

void test_move_only_types()
{
	MEOW_ENTER({ std::print("============= {} starting =============\n\n", __FUNCTION__); });
	MEOW_DEFER({ std::print("============= {} finished =============\n\n", __FUNCTION__); });

	BoundedQueue<move_only_t> queue(5);

	std::thread producer([&queue]() {
		for (int i = 0; i < 100; i++) {
			queue.push(move_only_t{i, std::format("value {}", i)});
		}
		queue.close();
	});

	std::vector<std::thread> consumers;
	for (int i = 0; i < 3; i++) {
		std::thread t([&queue]() {
			move_only_t value;
			while (queue.pop(value)) {
				std::print("thread got value {} + {}\n", value.value, value.strval);
			}
		});
		consumers.push_back(std::move(t));
	}

	producer.join();
	for (auto &t : consumers)
		t.join();
}

int main()
{
	test_1();
	test_move_only_types();

	return 0;
}