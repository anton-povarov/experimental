// Generated by ChatGPT
//
// Task 1: Thread-safe Bounded Queue
//
// Goal: Implement a thread-safe bounded queue with blocking push and pop operations. Requirements
// 	•	Use only C++ standard library (<mutex>, <condition_variable>, <queue>).
// 	•	push() should block when the queue is full, and resume when space becomes available.
// 	•	pop() should block when the queue is empty, and resume when an element is added.
// 	•	Make sure the queue works with multiple producer and consumer threads.
// 	•	Add a simple test program with several producers and consumers.

// Evaluation Focus
// 	•	Proper use of std::mutex and std::condition_variable
// 	•	Avoiding deadlocks and spurious wakeups
// 	•	Understanding of the producer–consumer problem
// 	•	Clean RAII design

#include <condition_variable>
#include <cstddef>
#include <deque>
#include <mutex>
#include <new> // std::hardware_destructive_interference_size
#include <print>
#include <thread>
#include <vector>

#include "meow/defer.hpp"

#define MEOW_ENTER(body)                                                                                     \
	{                                                                                                        \
		body;                                                                                                \
	} /**/

// ------------------------------------------------------------------------------------------------

template <typename T>
    requires std::is_nothrow_move_constructible_v<T> && std::is_nothrow_move_assignable_v<T>
class BoundedQueue
{
public:

	explicit BoundedQueue(size_t capacity)
	    : is_closed_{false}
	    , capacity_{capacity}
	{}

	void push(T value) // blocks if queue is full
	{
		{
			std::unique_lock lk(mtx_);
			cv_push_.wait(lk, [this]() { return is_closed_ || (q_.size() < capacity_); });

			if (is_closed_)
				return;

			// FIXME: can throw, std::bad_alloc, notification will not happen then
			// a fix could be to notify anyway, like with a scope exit guard
			// i see no way to split push_back into
			q_.emplace_back(std::move(value));
		}
		cv_pop_.notify_one(); // can be outside of the lock
	}

	// returns
	//  true if the caller has got a valid value and can continue get()-ing
	//  false - the caller should not use the value and should stop not call pop() again on this instance
	//        - the queue has been drained, before false is returned
	bool pop(T &out_value)
	{
		{
			std::unique_lock lk(mtx_);
			cv_pop_.wait(lk, [this]() { return is_closed_ || (q_.size() > 0); });

			// report close; make sure the queue is drained before we do that
			if (is_closed_ && (q_.size() == 0))
				return false;

			// is it better to move to a local variable first?
			// might improve memory locality under lock
			out_value = std::move(q_.front());
			q_.pop_front();
		}

		cv_push_.notify_one();
		return true;
	}

	void close()
	{
		{
			std::unique_lock lk(mtx_);
			is_closed_ = true;
		}
		cv_pop_.notify_all();
		cv_push_.notify_all();
	}

private:
	alignas(std::hardware_destructive_interference_size) struct
	{
		bool         is_closed_;
		size_t const capacity_;
	};
	alignas(std::hardware_destructive_interference_size) std::deque<T> q_;
	alignas(std::hardware_destructive_interference_size) std::mutex mtx_;
	alignas(std::hardware_destructive_interference_size) std::condition_variable cv_pop_;
	alignas(std::hardware_destructive_interference_size) std::condition_variable cv_push_;
};
