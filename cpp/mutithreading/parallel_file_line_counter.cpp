// Generated by ChatGPT
//
// Task 2: Parallel File Line Counter
//
// Goal: Count the total number of lines in all text files under a given directory using multiple threads.
//
// Implement a program:
// ./line_counter /path/to/dir [num_threads]

// The program should:
// 	1.	Recursively traverse the directory.
// 	2.	For each file, count the number of \n characters.
// 	3.	Distribute file processing among worker threads.
// 	4.	Print the total number of lines.

// Constraints
// 	•	Use C++17 or later.
// 	•	Use only POSIX and standard library functions (e.g., <filesystem>, <thread>, <future>, <atomic>).
// 	•	Handle large files efficiently — avoid reading the whole file into memory.
// 	•	Skip binary files or files larger than a threshold (e.g. 1GB).

// Evaluation Focus
// 	•	Work queue or task pool design
// 	•	Load balancing and thread synchronization
// 	•	Use of std::async, std::thread, or a custom thread pool
// 	•	Efficient file I/O (buffered reading)
// 	•	Use of atomics for counting or reducing results safely

// Bonus
// Implement your own lightweight thread pool (if time allows).

#include <cstddef>
#include <exception>
#include <print>
#include <unordered_map>

#include "concurrent_bounded_queue.hpp"

// file stuff
#include <filesystem>
#include <fstream>
namespace fs = std::filesystem;

struct qmessage_t
{
	std::string filename;
};

void run_test_1(std::string const &dir_path)
{
	std::mutex                                line_counts_mtx;
	std::unordered_map<std::string, uint64_t> line_counts;

	std::exception_ptr reader_exception_p; // no mutex, single writer

	BoundedQueue<qmessage_t> filenames_q{100};

	std::thread directory_reader{[&dir_path, &filenames_q, &reader_exception_p]() {
		// some day will be replaced by
		// std::scope_exit([&]() { filenames_q.close(); });
		MEOW_DEFER({ filenames_q.close(); });

		try {
			if (!fs::exists(dir_path)) {
				throw std::runtime_error(std::format("path does not exist: {}\n", dir_path));
			}
			if (!fs::is_directory(dir_path)) {
				throw std::runtime_error(std::format("path is not a directory: {}\n", dir_path));
			}

			for (auto const &file : fs::recursive_directory_iterator(dir_path)) {
				if (!file.is_regular_file()) {
					continue;
				}

				filenames_q.push(qmessage_t{file.path().string()});
			}
		}
		catch (std::exception const &e) {
			reader_exception_p = std::current_exception(); // we're the single writer
			return;
		}
	}};

	std::vector<std::thread> line_counter_threads;
	for (int i = 0; i < 5; i++) {
		line_counter_threads.emplace_back([&]() {
			std::unordered_map<std::string, uint64_t> line_counts_local;

			qmessage_t msg;
			while (filenames_q.pop(msg)) {
				// got a file to read, not an error
				auto      pair = line_counts_local.emplace(msg.filename, 0);
				uint64_t &line_counter = pair.first->second;

				try {
					auto *f = fopen(msg.filename.c_str(), "rb");
					if (NULL == f)
						throw std::system_error(errno, std::generic_category(), "open");

					MEOW_DEFER({ fclose(f); });

					char buf[4096];
					while (true) {
						size_t n = fread(buf, 1, sizeof(buf), f);
						if (n <= 0) {
							if (feof(f))
								break;
							if (ferror(f)) {
								throw std::runtime_error(std::format("fread: {} {} ({})", msg.filename,
								                                     strerror(errno), errno));
							}
						}
						for (int i = 0; i < n; /**/) {
							auto *p = (char const *)std::memchr(buf + i, '\n', n - i);
							if (p == nullptr)
								break;
							line_counter++;
							i = p - buf + 1;
						}
					}
				}
				catch (std::exception const &e) {
					std::print("line_counter: {}, {}\n", msg.filename, e.what());
				}

				if (false) { // OLD implementation
					std::ifstream f(msg.filename, std::ios::binary);
					if (!f.is_open()) {
						std::print(stderr, "{}: {} ({})\n", msg.filename, strerror(errno), errno);
						continue;
					}

					try {
						// FIXME
						// this is highly inefficient, since we just need to count lines,
						// not copy them into an in-memory string
						for (std::string line; std::getline(f, line);) {
							line_counter++;
						}
					}
					catch (std::exception const &e) {
						std::print("line_counter: {}, {}\n", msg.filename, e.what());
					}
				}
			}

			// merge into the global map
			{
				std::scoped_lock lk(line_counts_mtx);
				for (auto const &[key, value] : line_counts_local)
					line_counts[key] += value;
			}
		});
	}

	directory_reader.join();
	for (auto &t : line_counter_threads)
		t.join();

	// check for error
	try {
		if (reader_exception_p)
			std::rethrow_exception(reader_exception_p);
	}
	catch (std::exception const &e) {
		std::print(stderr, "error: {}\n", e.what());
		return;
	}

	// no need to lock here, all writers have already exited
	for (auto const &[key, value] : line_counts)
		std::print("{:> 8d} {}\n", value, key);
}

int main(int argc, char **argv)
{
	if (argc < 2) {
		std::print(stderr, "usage: {} <path to directory to traverse>\n", argv[0]);
		return 1;
	}

	run_test_1(argv[1]);

	return 0;
}